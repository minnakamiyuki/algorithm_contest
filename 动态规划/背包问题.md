先来讲一个比较经典的01背包问题, 就是有n个物品和一个容量为W的背包, 每个背包有重量为wi和vi的属性, 要求选若干物品放在背包最大化价值

由于每个物体只有两种可能的状态（取与不取）

#### 0-1背包和完全背包问题, 关键是要记住他们的区别

注意dp状态的设计是怎么样的,

~~~
定义f[i][j]是前i个物品, 容量为j的背包达到的最大总价值
那么可以列出状态转移方程;
f[i][j] = max(f[i - 1][j], f[i - 1][j - wi] + vi);
由于对fi影响的只有f[i - 1]因此可以压缩一维;
关于这个的枚举好好思考一下;
for (int i = 1; i <= n; i++) 
	for (int l = 0; l <= W - w[i]; l++) 
		f[l + w[i]] = max(f[l + w[i]], f[l] + vi);
// 注意看, 当j >= wi时, f[i, j]会被f[i, j - w[i]]影响的, 这意味着此时物品i可以多次被放入当前背包(实际上这是完全背包的解法)


// 所以0-1背包的核心与完全背包的核心部分的枚举是反过来的, 即0 - 1背包是从大往小枚举的

for (int i = 1; i <= n; i++)
	for (int l = W; l >= w[i]; l--)
		f[l] = max(f[l], f[l - w[i]] + v[i]);
~~~

#### 接下来考虑分组背包

什么是分组背包问题呢， 实际上就是将物品分组，每组的物品相互冲突，只能选一个物品进去, 其实本质上是对每一组进行一个0-1背包就好了

~~~
// 核心代码
for (int k = 1; k <= ts; k++) // k组
	for (int i = m; i >= 0; i--)
		for (int j = 1; j <= cnt[k]; j++) {
			if (i >= w[t[k][j]]) {
				dp[i] = max(dp[i], dp[i - w[t[k]][j]] + c[t[k][j]]);
			}
}
~~~

